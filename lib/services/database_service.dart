import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:devup/model/user.dart';
import 'package:firestore_helpers/firestore_helpers.dart';


////////////////////////////////////////////////////////////////////////////////////
/// IMPORTANT: All objects contain there documentID as property.
/// This ID is generated by the App, not be FireStore. If objects have unique names
/// like categories that name is used as key. Otherwise a UUID is generated
////////////////////////////////////////////////////////////////////////////////////


class ObjectDoesNotExistsException implements Exception
{
  final String message;

  
    ObjectDoesNotExistsException(this.message);
  
  @override
  String toString() {
      return message;
    }

}


abstract class DatabaseService {
  ///
  /// User functions
  ///
  Future<bool> updateUser(User user);

  Future<User> getUser(String userID);


}
/*
class DatabaseServiceFireStore implements DatabaseService {
  final UserSerializer _userSerializer = new UserSerializer();
  final EventCategorySerializer _categorySerializer = new EventCategorySerializer();
  final EventTypeSerializer _eventTypeSerializer = new EventTypeSerializer();
  final EventSerializer _eventSerializer = new EventSerializer();
  final ChatEntrySerializer _chatEntrySerializer = new ChatEntrySerializer();
  final PlaceSerializer _placeSerializer = new PlaceSerializer();
  final InvitationSerializer _invitationSerializer = new InvitationSerializer();

  final userCollection = Firestore.instance.collection("users");
  final categoryCollection = Firestore.instance.collection("category");
  final eventTypeCollection = Firestore.instance.collection("eventTypes");
  final eventCollection = Firestore.instance.collection("events");
  final placeCollection = Firestore.instance.collection("places");
  final invitationCollection = Firestore.instance.collection("invitations");


  ////////////////////////////////////////////////////////////////////////////////////
  /// Users
  ///////////////////////////////////////////////////////////////////////////////////

  @override
  Future<bool> updateUser(User user) async {
    try {
      await userCollection.document(user.id).setData(_userSerializer.toMap(user));
      return true;
    } catch (e) {
      print(e);
      //todo logging
      return false;
    }
  }

  @override
  Future<User> getUser(String userID) async {
    try {
      var userData = await userCollection.document(userID).get();
      if (userData.exists) {
        return _userSerializer.fromMap(userData.data);
      }
    } on Exception catch (ex) {
      print(ex);
      // TODO add some logger
    }

    return null;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////
  /// EventCategories
  /////////////////////////////////////////////////////////////////////////////////////////////

  @override
  Future<List<EventCategory>> getEventCategories() async {
    try {
      var categories = await categoryCollection.getDocuments();
      if (categories != null && categories.documents != null && categories.documents.isNotEmpty) {
        return categories.documents
            .map((document) => _categorySerializer.fromMap(document.data))
            .toList();
      }
    } on Exception catch (ex) {
      print(ex);
      // TODO add some logger
    }

    return null;
  }

  @override
  Future<bool> updateEventCategory(EventCategory category) async {
    try {
      await categoryCollection.document(category.name).setData(_categorySerializer.toMap(category));
      return true;
    } catch (e) {
      print(e);
      //todo logging
      return false;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////////
  /// EventTypes
  //////////////////////////////////////////////////////////////////////////////////////////

  @override
  Future<List<EventType>> getEventTypes() async {
    try{
      var eventTypes = await eventTypeCollection.getDocuments();
      if(eventTypes != null && eventTypes.documents != null && eventTypes.documents.isNotEmpty) {
        return eventTypes.documents.map((document) => _eventTypeSerializer.fromMap(document.data))
        .toList();
      }
    } on Exception catch (ex) {
      print(ex);
      // TODO add some logger
    }

    return null;
  }

  @override
  Future<bool> updateEventType(EventType eventType) async {
    try {
      await eventTypeCollection.document(eventType.name).setData(_eventTypeSerializer.toMap(eventType));
      return true;
    } catch (e) {
      print(e);
      //todo logging
      return false;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////////
  /// Events
  //////////////////////////////////////////////////////////////////////////////////////////

  @override
  Stream<List<Event>> getEvents(
      {List<QueryConstraint> constraints, List<ItemFilter<Event>> filters}) {
    try {
      Query query = buildQuery(collection: eventCollection, constraints: constraints, orderBy: [
        new OrderConstraint("location",
            true), // We have to add this otherwise we cannot order by Starttime due to limitation of firebase
        new OrderConstraint("startTime", false),
      ]);

      return getDataFromQuery(
          query: query,
          clientSitefilters: filters,
          mapper: (eventDoc) => _eventSerializer.fromMap(eventDoc.data));
    } on Exception catch (ex) {
      print(ex);
      // TODO add some logger
    }

    return null;
  }

  @override
  Stream<Event> getEventUpdates(Event event) {
    return eventCollection
        .document(event.id)
        .snapshots()
        .map((eventDoc) {
          if (eventDoc.exists)
          {
            return _eventSerializer.fromMap(eventDoc.data);
          }
          throw ObjectDoesNotExistsException('Event ${event.id} does not exists');
        });
  }

  @override
  Future<bool> updateEvent(Event event) async {
    try {
      var eventData = _eventSerializer.toMap(event);
      await eventCollection.document(event.id).setData(eventData);
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());
      await sl
          .get<ErrorReporter>()
          .logException(e, message: 'Error while updating Event: ${event.id}', stackTrace: stack);
      return false;
    }
  }

  @override
  Future<bool> deleteEvent(Event event) async {
    try {
      await eventCollection.document(event.id).delete();
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());
      await sl
          .get<ErrorReporter>()
          .logException(e, message: 'Error deleting Event: ${event.id}', stackTrace: stack);
      return false;
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  /// ChatEntries
  /////////////////////////////////////////////////////////////////////////////

  @override
  Future<bool> deleteChatEntry(ChatEntry chatEntry) async {
    try {
      await eventCollection.document(chatEntry.eventId).collection("chat").document(chatEntry.id).delete();
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());

      await sl
          .get<ErrorReporter>()
          .logException(e, message: 'Error deleting ChatEntry: ${chatEntry.id}', stackTrace: stack);

      return false;
    }
  }

  @override
  Stream<List<ChatEntry>> getChatEntries(Event event,
      {List<QueryConstraint> constraints, List<ItemFilter<ChatEntry>> filters}) {
    try {
      Query query = buildQuery(collection: eventCollection.document(event.id).collection("chat"), constraints: constraints, orderBy: [
        new OrderConstraint("creationTime", false),
      ]);

      return getDataFromQuery(
          query: query,
          clientSitefilters: filters,
          mapper: (chatEntryDoc) => _chatEntrySerializer.fromMap(chatEntryDoc.data));
    } on Exception catch (ex, stack) {
      print(ex);
      sl
          .get<ErrorReporter>()
          .logException(ex, message: 'Error while getting ChatEntries', stackTrace: stack);
    }

    return null;
  }

  @override
  Future<bool> updateChatEntry(ChatEntry chatEntry) async {
    try {
      var chatEntryData = _chatEntrySerializer.toMap(chatEntry);
      await eventCollection.document(chatEntry.eventId).collection("chat").document(chatEntry.id).setData(chatEntryData);
      return true;
    } catch (ex, stack) {
      print(ex);
      print(stack.toString());
      await sl.get<ErrorReporter>().logException(ex,
          message: 'Error while updating ChatEntry: ${chatEntry.id}', stackTrace: stack);
      return false;
    }
  }

  @override
  Future<bool> deletePlace(Place place) async {
    try {
      await placeCollection.document(place.id).delete();
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());
      await sl
          .get<ErrorReporter>()
          .logException(e, message: 'Error deleting Place: ${place.id}', stackTrace: stack);
      return false;
    }
  }

  @override
  Stream<Place> getPlaceUpdates(Place place) {
    return placeCollection
        .document(place.id)
        .snapshots()
        .map((placeDoc) {
          if (placeDoc.exists)
          {
            return _placeSerializer.fromMap(placeDoc.data);
          }
          throw ObjectDoesNotExistsException('Place ${place.id} does not exists');
        });
  }

  @override
  Stream<List<Place>> getPlaces({List<QueryConstraint> constraints, List<ItemFilter<Place>> filters}) {
    try {
      Query query = buildQuery(collection: placeCollection, constraints: constraints, orderBy: [
        new OrderConstraint("location",
            true),        
      ]);

      return getDataFromQuery(
          query: query,
          clientSitefilters: filters,
          mapper: (placeDoc) {
            return _placeSerializer.fromMap(placeDoc.data);
          });
    } on Exception catch (ex, stack) {
      print(ex);
      sl
          .get<ErrorReporter>()
          .logException(ex, message: 'Error in getPlaces', stackTrace: stack);
    }

    return null;
  }

  @override
  Future<bool> updatePlace(Place place) async {
    try {
      var placeData = _placeSerializer.toMap(place);
      await placeCollection.document(place.id).setData(placeData);
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());
      await sl
          .get<ErrorReporter>()
          .logException(e, message: 'Error while updating Place: ${place.id}', stackTrace: stack);
      return false;
    }
  }

  @override
  Future<bool> createInvitation(Invitation invitation) async {
    try {
      var invitationData = _invitationSerializer.toMap(invitation);
      await invitationCollection.add(invitationData);
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());
      await sl
          .get<ErrorReporter>()
          .logException(e, message: 'Error while adding Invitation: $invitation', stackTrace: stack);
      return false;
    }
  }

  @override
  Stream<List<Invitation>> getInvitations({List<QueryConstraint> constraints, List<ItemFilter<Invitation>> filters}) {
    try {
      Query query = buildQuery(collection: invitationCollection, constraints: constraints, orderBy: [
        new OrderConstraint("sender", false),
      ]);

      return getDataFromQuery(
          query: query,
          clientSitefilters: filters,
          mapper: (chatEntryDoc) => _invitationSerializer.fromMap(chatEntryDoc.data));
       } on Exception catch (ex, stack) {
        print(ex);
        sl.get<ErrorReporter>()
          .logException(ex, message: 'Error while getting Invitations', stackTrace: stack);
    }

    return null;
  }
}
*/