import 'dart:async';
import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:devup/model/user.dart';
import 'package:firestore_helpers/firestore_helpers.dart';
import 'package:rxdart/rxdart.dart';
import 'package:rxdart/subjects.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

////////////////////////////////////////////////////////////////////////////////////
/// IMPORTANT: All objects contain there documentID as property.
/// This ID is generated by the App, not be FireStore. If objects have unique names
/// like categories that name is used as key. Otherwise a UUID is generated
////////////////////////////////////////////////////////////////////////////////////

class ObjectDoesNotExistsException implements Exception {
  final String message;

  ObjectDoesNotExistsException(this.message);

  @override
  String toString() {
    return message;
  }
}

abstract class DatabaseService {
  User currentUser;

  PublishSubject<List<User>> matchingUsersStream;

  Future<bool> saveUser(User user);

  Future<User> getCurrentUser();

  void matchUsers();
}

class DatabaseServiceFireStore implements DatabaseService {
  final userCollection = Firestore.instance.collection("users");
  final userSerializer = UserJsonSerializer();

  @override
  Future<bool> saveUser(User user) async {
    try {
      if (user.id == null) {
        Uuid uuid = Uuid();
        user.id = uuid.v1();
      }
      await userCollection.document(user.id).setData(userSerializer.toMap(user));

      SharedPreferences prefs = await SharedPreferences.getInstance();
      prefs.setString('userData', json.encode(userSerializer.toMap(user)));

      currentUser = user;
      return true;
    } catch (e) {
      print(e);
      //todo logging
      return false;
    }
  }

  @override
  User currentUser;

  @override
  Future<User> getCurrentUser() async {
    if (currentUser == null) {
      SharedPreferences prefs = await SharedPreferences.getInstance();
      var userData = prefs.getString('userData');
      if (userData == null) {
        currentUser = User();
      } else {
        return userSerializer.fromMap(json.decode(userData));
      }
    }
    return currentUser;
  }

  StreamSubscription matchingUsersSubscription;

  @override
  void matchUsers() async {
    matchingUsersSubscription?.cancel();

    // Currently we don't do any matching but take the full user document collection
    // instead of userCollection we would then use a Firestore Query
    matchingUsersSubscription = Observable(userCollection.snapshots())
        .map<Iterable<User>>((docSnapShots) => docSnapShots.documentChanges
            // we only want initial and added documents
            .where((documentChange) =>
                documentChange.type == DocumentChangeType.added)
            .map(
              (docChange) => userSerializer.fromMap(docChange.document.data),
            )).listen( (addedDocs) => matchingUsersStream.add(addedDocs.toList()));
  }

  @override
  PublishSubject<List<User>> matchingUsersStream = PublishSubject<List<User>>();
}
