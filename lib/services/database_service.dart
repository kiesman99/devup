import 'dart:async';
import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:devup/model/user.dart';
import 'package:firestore_helpers/firestore_helpers.dart';
import 'package:rxdart/rxdart.dart';
import 'package:rxdart/subjects.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

////////////////////////////////////////////////////////////////////////////////////
/// IMPORTANT: All objects contain there documentID as property.
/// This ID is generated by the App, not be FireStore. If objects have unique names
/// like categories that name is used as key. Otherwise a UUID is generated
////////////////////////////////////////////////////////////////////////////////////

class ObjectDoesNotExistsException implements Exception {
  final String message;

  ObjectDoesNotExistsException(this.message);

  @override
  String toString() {
    return message;
  }
}

abstract class DatabaseService {

  PublishSubject<List<User>> matchingUsersStream;

  Future<bool> updateUser(User user);

  Future<User> getUser(String userID);

  void matchUsers(User user);
}

class DatabaseServiceFireStore implements DatabaseService {
  final _userCollection = Firestore.instance.collection("users");
  final _userSerializer = UserJsonSerializer();

  @override
  Future<bool> updateUser(User user) async {
    try {
      if (user.id == null) {
        Uuid uuid = Uuid();
        user.id = uuid.v1();
      }
      await _userCollection.document(user.id).setData(_userSerializer.toMap(user));

      return true;
    } catch (e) {
      print(e);
      //todo logging
      return false;
    }
  }

  @override
  Future<User> getUser(String userID) async {
    try {
      var userData = await _userCollection.document(userID).get();
      if (userData.exists) {
        return _userSerializer.fromMap(userData.data);
      }
    } on Exception catch (ex) {
      print(ex);
      // TODO add some logger
    }

    return null;
  }

  StreamSubscription matchingUsersSubscription;

  @override
  void matchUsers(User user) async {
    matchingUsersSubscription?.cancel();

    // Currently we don't do any matching but take the full user document collection
    // instead of userCollection we would then use a Firestore Query
    matchingUsersSubscription = Observable(_userCollection.snapshots())
        .map<Iterable<User>>((docSnapShots) => docSnapShots.documentChanges
            // we only want initial and added documents
            .where((documentChange) =>
                documentChange.type == DocumentChangeType.added)
            .map(
              (docChange) => _userSerializer.fromMap(docChange.document.data),
            )).listen( (addedDocs) => matchingUsersStream.add(addedDocs.toList()));
  }

  @override
  PublishSubject<List<User>> matchingUsersStream = PublishSubject<List<User>>();
}
